<!DOCTYPE html>
<html>
<head>
	<title> Campus Mapper </title>
</head>
<body>
	<h1> Campus Mapper </h1>

	
	<div id="map-container" style="position: relative; width: 100%; height: 100%; border: 1px solid #ccc;">
		<canvas id="campus-map"></canvas>

		<div id="input-overlay" style="position: absolute; top: 10px; left: 10px; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
			<form class="prelim-info" data-info="room" id="room-form">
				<label for="room-id">Enter Room:</label>
				<input type="text" id="room-id" />
				<input type="submit" value="Submit" />
				<button id="permissionButton"> Grant permission if on IOS </button>
			</form>
			
		</div>

		
		

	</div>
	
	<div id="compass-container" style="position: absolute; top: 150px; left: 200px; background: white;">
		<canvas id="compass">
		
		</canvas>
	</div>
	
	<div id="dev-info" style="position: absolute; top: 0px; left: 0px; background: white; padding 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
		<form class="building-info" id="building-form">
			<label id="building-prefix"> Building: Outside </label>
		</form>
		
		<form class="compass-info" id="compass-form">
			<label id="compass-value"> Compass: 0 </label>
		</form>
	</div>	
	
	<div id="fading">
	
		<h1 id="fadingText"> This text will fade in </h1>
	
	</div>
	
	
	
	
	<style>
		html, body {
			margin: 0;
			padding: 0;
			height: 100%;
			display: flex;
			flex-direction: column;
			background-color: green;
		}
		
		
		#fading {
			position: absolute;
			top: 12%;
			left: 20%;
			transform: translate(-50%, -50%);
			display: flex;
			background: rgba(128, 128, 128, 0.85);
		}
		
		h1 {
			text-align: center;
			font-family: verdana;
			font-size: 28px;
			color: white;
			margin-bottom: 25px;
		}
		
		
		
		
		
		
		#dev-info {
			display: flex;
			flex-direction: column;
			flex: 1;
			background-color: white;
		}
		
		#fadingText {
		  opacity: 0;
		  color: white;
		  font-size: 20px;
		  transition: opacity 0.75s ease-in-out; 
		}
		
		#map-container {
			display: flex;
			flex: 1;
			background-color: grey;
			border-radius: 10px;
			box-shadow: 0 4px 12px rgba(0,0,0,0.1);
			padding: 0px;
			margin-top: 0px;
			width: 550px;
		}
		
		
		#input-overlay {
			width: 155px
		}
		
		

		#compass {
			width: 100px; 
			height: 100px; 
			border: 1px solid black;
			background-color: rgba(128, 128, 128, 0.85);
			position: absolute;
			top: 0px;
			left: 100px;
		}
		
		
		
		
		label {
			font-family: verdana;
			font-weight: bold;
			color: #555;
			width: 250px;
		}
		
		
		input[type="text"] {
			padding: 8px;
			border-radius: 5px;
			font-size: 16px;
			flex-grow: 1;
			border: 1px solid #ccc;
			width: 50%;
			box-sizing: border-box;
		}
		
		input[type="text"]:focus {
			background-color: lightgreen;
		}
		
		input[type="submit"] {
			background-color: #3BB143;
			color: white;
			padding: 10px 20px;
			font-size: 16px;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			transition: 0.3s;
			align-self: center;
		}
		input[type="submit"]:hover {
			background-color: #0B6623;
		}
		
		
		form {
			display: flex;
			flex-direction: column;
			gap: 15px;
			width: 100%;
		}



		canvas {
			display: flex; 
			position: sticky; 
			top: 0; 
			left: 280px;
		}
		
		
		@media (max-width: 800px) {
		  .flex-container {
			flex-direction: column;
		  }
		}

		
		
	</style>
	
	<script>
		const canvas = document.getElementById("campus-map");
		const ctx = canvas.getContext("2d");

		const aspectRatio = 1708 / 712; 

		
		let canvasWidth = window.innerWidth * 0.85;
		let canvasHeight = canvasWidth / aspectRatio;

		
		/*if (canvasHeight > window.innerHeight * 0.85) {
			canvasHeight = window.innerHeight * 0.85;
			canvasWidth = (canvasHeight) * aspectRatio;
		}*/	

		
		canvas.width = canvasWidth;
		canvas.height = canvasHeight;
		
		
		const img = new Image();
		img.src = "campuspichighres.png";
		
		
		const compassCanvas = document.getElementById("compass");
		const ctxCompass = compassCanvas.getContext("2d");
		
		const imgCompass = new Image();
		imgCompass.src = "compass.png";
		
		compassCanvas.width = 100;
		compassCanvas.height = 100;
		
		
		
		
		const form = document.getElementById("room-form");
		
		
		const rows = 15;
		const diameter = canvas.height / rows; 
		const cols = Math.ceil(canvas.width / diameter);



		var zones = [];
		//prefix: "UR", prefix: "BU", prefix: "LB", prefix: "LL", prefix: "MU", prefix: "SC", prefix: "BH", prefix: "SR", prefix: "SI", prefix "FH prefix: "WH"
		var buildings = [];

		buildings[0] = {prefix: "UR", lowerBound: (535 / 712) * canvas.height, upperBound: canvas.height, leftBound: (100 / 1708) * canvas.width, rightBound: (225 / 1708) * canvas.width};
		
		buildings[1] = {prefix : "BU", lowerBound: (350 / 712) * canvas.height, upperBound: (530 / 712) * canvas.height, leftBound: (115 / 1708) * canvas.width, rightBound: (300 / 1708) * canvas.width};
		
		buildings[2] = {prefix: "LL", lowerBound: (245 / 712) * canvas.height, upperBound: (452 / 712) * canvas.height, leftBound: (327 / 1708) * canvas.width, rightBound: (485 / 1708) * canvas.width};
		
		buildings[3] = {prefix: "LB", lowerBound: (453 / 712) * canvas.height, upperBound: (648 / 712) * canvas.height, leftBound: (367 / 1708) * canvas.width, rightBound: (575 / 1708) * canvas.width};
		
		buildings[4] = {prefix: "MU", lowerBound: (355 / 712) * canvas.height, upperBound: (516 / 712) * canvas.height, leftBound: (650 / 1708) * canvas.width, rightBound: (915 / 1708) * canvas.width};
		
		buildings[5] = {prefix: "SC", lowerBound: (360 / 712) * canvas.height, upperBound: (558 / 712) * canvas.height, leftBound: (990 / 1708) * canvas.width, rightBound: (1173 / 1708) * canvas.width};
		
		buildings[6] = {prefix: "BH", lowerBound: (40 / 712) * canvas.height, upperBound: (494 / 712) * canvas.height, leftBound: (1187 / 1708) * canvas.width, rightBound: (1360 / 1708) * canvas.width};
		
		buildings[7] = {prefix: "SR", lowerBound: (257 / 712) * canvas.height, upperBound: (480 / 712) * canvas.height, leftBound: (1361 / 1708) * canvas.width, rightBound: (1516 / 1708) * canvas.width};
		
		buildings[8] = {prefix: "SI", lowerBound: (288 / 712) * canvas.height, upperBound: (480 / 712) * canvas.height, leftBound: (1517 / 1708) * canvas.width, rightBound: (1674 / 1708) * canvas.width};
		
		buildings[9] = {prefix: "FH", lowerBound: (110 / 712) * canvas.height, upperBound: (290 / 712) * canvas.height, leftBound: (1546 / 1708) * canvas.width, rightBound: (1669 / 1708) * canvas.width};
		
		buildings[10] = {prefix: "WH", lowerBound: (14 / 712) * canvas.height, upperBound: (111 / 712) * canvas.height, leftBound: (1367 / 1708) * canvas.width, rightBound: (1626 / 1708) * canvas.width};
		
		
		const ZONES = {};
		
		const PATHS = [];
		
		
		
		
		
		var latitude;
		var longitude;
		
		var travelDir;
		
		function leftOrRight() {
			let index = 0;
			if(activatedZone === undefined){
				activatedZone = 0;
			}
			let activeBuilding = zones[activatedZone].building;
			for(let i = 0; i < buildings.length; i++){
				if(roomName.includes(buildings[i])){
					index = i;
				}
			}
			
			if(buildings.indexOf(activeBuilding) < index){
				travelDir = 0;
			} else if(buildings.indexOf(activeBuilding) > index){
				travelDir = 1;
			} else {
				travelDir = 2;
			}
		}
		
		
		
		function compassPointer() {
		
			let angle = compass;
			ctxCompass.clearRect(0, 0, compassCanvas.width, compassCanvas.height);
			
			ctxCompass.save();
			ctxCompass.translate(compassCanvas.width / 2, compassCanvas.height / 2);
			
			ctxCompass.rotate(angle * Math.PI / 180);
			
			
		
		
			ctxCompass.drawImage(imgCompass, -imgCompass.width / 2, -imgCompass.height / 2);
			
			ctxCompass.restore();
			
		
		}
		
		
		function draw() {
			let watchId = navigator.geolocation.watchPosition(
			  function(position) {
				
				latitude = position.coords.latitude;
				longitude = position.coords.longitude;
				//console.log(`Updated Latitude: ${latitude}, Longitude: ${longitude}`);
			  },
			  function(error) {
				
				//console.error("Error watching position:", error);
			  },
			  {
				enableHighAccuracy: true,
				timeout: 5000,
				maximumAge: 0
			  }
			);
			//41.502143341689326, -81.67854782348736
			//latitude = 41.502143341689326;
			//longitude = -81.67854782348736;
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Can be modified to follow the users position
			
			var xvalue;
			var yvalue;
			var zoom;
			
			if(inside){
				camera.x = userPos.x - canvas.width / (2 * camera.scale);
				camera.y = userPos.y - canvas.height / (2 * camera.scale);
				camera.scale = 3; 
			} else {
				xvalue = 0;
				yvalue = 0;
				zoom = 1;
			}
			camera = { x: xvalue, y: yvalue, scale: zoom};
			
			


			renderScene(camera, diameter, cols);
			
			if(currBuilding === undefined){
				document.getElementById("building-prefix").textContent = "Building: Outside";
			} else {
				document.getElementById("building-prefix").textContent = "Building: " + currBuilding;
			}
			
			
			leftOrRight();
			if(travelDir == 0){
				document.getElementById("fadingText").textContent = zones[activatedZone].directionsRight;
				//compassPointer();
			} else if(travelDir == 1){
				document.getElementById("fadingText").textContent = zones[activatedZone].directionsLeft;
				//compassPointer();
			} else {
				//compassPointer();
			}
			
			compassPointer();
					
			document.getElementById("fadingText").style.opacity = 1;



			requestAnimationFrame(draw);
		}
		

		
		
		if (typeof DeviceOrientationEvent.requestPermission === 'function') {
		  document.getElementById('permissionButton').addEventListener('click', () => {
			DeviceOrientationEvent.requestPermission().then(permissionState => {
			  if (permissionState === 'granted') {
				window.addEventListener('deviceorientation', handler);
			  }
			});
		  });
		} else {
			window.addEventListener('deviceorientation', handler);
		}
			
					
		var roomName = " ";
		form.addEventListener("submit", function(event) {
			event.preventDefault();  // prevent page reload

			roomName = document.getElementById("room-id").value;
			
			
			
		
		});
		var lat;
		var longit;
		
		var compass = 0;
		function handler(e) {
			if(e.alpha != null) {
				compass = 360 - e.alpha;
			}
		}
		
		
		
		

		// Top left: 41.50328051569975, -81.67904912462858
		// Bottom left: 41.50146378558553, -81.67868811305225
		// Top Right: 41.5038595529573, -81.67282733226762
		// Bottom Right: 41.5021184731077, -81.67242593073586
		
	
		
		function drawPolygon(x1, y1, x2, y2, x3, y3, x4, y4, inZone){
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.lineTo(x3, y3);
			ctx.lineTo(x4, y4);
			ctx.closePath();
			ctx.fillStyle = (inZone) ? 'rgba(0, 255, 0, 0.25)' : 'rgba(0, 0, 0, 0)';
			ctx.strokeStyle = 'blue';
			ctx.lineWidth = 2;

			ctx.fill();
			ctx.stroke();
		}
			
		
		
		// ZONES (nodes) & PATHS (edges)
		function bread(start, end, ZONES, PATHS){
			let queue = [[start, [start]]]; // Initialize queue to contain starting point and our current path (just the start right now)
			let visited = new Set([start]); // Set our visited locations to a "set" with our current location
			
			while (queue.length > 0) {
				let [currentZone, path] = queue.shift();
				
				
				if(currentZone === end){ // If we reached our destination it is the shortest path 
					return path;
				}
				
				var neighbors = [];
				
				
				// For each element in our PATHS array, if that PATH comes from our currentZone we add it to the neighbors (i.e. it is connected)
				for(let i = 0; i < PATHS.length; i++) { 
					if(PATHS[i].from === currentZone){
						neighbors.push(PATHS[i]);
					}
				}
				
				for(let i = 0; i < neighbors.length; i++){
					let nextZone = neighbors[i].to;
					if(!visited.has(nextZone)){
						visited.add(nextZone);
						let newPath = [...path, nextZone];
						queue.push([nextZone, newPath]);
					}
				}
			}
		}
					
					
			
		
			
			
		
		
		var activatedZone;	
		var inZone;
		var inside;
		var currBuilding;
		
		
		// Main routing loop
		function handleZones(diameter, cols) {	
			ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
			
			
			let mapY = latLonConvert(latitude, longitude).y;
			let mapX = latLonConvert(latitude, longitude).x;
			
			
			for(let i = 0; i < buildings.length; i++){
				inZone = 0;
				if((mapX < buildings[i].rightBound & mapX > buildings[i].leftBound) & 
				   (mapY < buildings[i].upperBound & mapY > buildings[i].lowerBound)){
					inZone = 1;
					inside = 1;
					currBuilding = buildings[i].prefix;
				}
				drawPolygon(buildings[i].leftBound, buildings[i].lowerBound, 
							buildings[i].rightBound, buildings[i].lowerBound,
							buildings[i].rightBound, buildings[i].upperBound,
							buildings[i].leftBound, buildings[i].upperBound, inZone);
				
			}
			
				
			
			if(inside){
				// TODO: add a BFS between the starting position in the currBuilding and the destination room (maybe assign destination room to a specific hallway first to avoid writing more edges and nodes and directions??)
			} 
			// Draw user location as a red dot
			ctx.beginPath();
			ctx.arc(mapX, mapY, 5, 0, 2 * Math.PI);
			ctx.fillStyle = "rgba(255, 0, 0, 1.0)";
			ctx.fill();
			ctx.strokeStyle = "black";
			ctx.stroke();
			
		
			
			
		}
		
		function renderScene(camera, diameter, cols) {
			ctx.setTransform(camera.scale, 0, 0, camera.scale, -camera.x*camera.scale, -camera.y*camera.scale);
			handleZones(diameter, cols);
		}
		
		// Top left of image: 41.50385334040492, -81.6804914654469
		// Bottom right of image: 41.50134173780734, -81.67246588380492
		
		function latLonConvert(lat, lon){
			let xscale = (81.6804914654469 + lon) / (81.6804914654469 - 81.67246588380492);
			let yscale = (41.50385334040492 - lat) / (41.50385334040492 - 41.50134173780734);
			
			return {
				x: xscale * canvas.width,
				y: yscale * canvas.height
			}
		}
		
		
		img.onload = () => {
			draw();
		};
		
		
		

		
	</script>
</body>

</html>

